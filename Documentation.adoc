= Εργασια Multimedia Streaming
Χρήστος Βρέκος (Α.Μ. 21390027)
:doctype: book
:icons: font
:source-highlighter: pygments
:pygments-style: manni
:pygments-linenums-mode: inline
:toc: left
:toc-title: Πίνακας περιεχομένων
:toclevels: 4
:sectlinks:
:sectanchors:
:pdf-style: basic
:pdf-fontsdir: fonts/
:pdf-stylesdir: styles/

== Aρχιτεκτονική του Συστήματος

*Περιγραφή του συστήματος και των λειτουργιών του:* +
   Το σύστημα αποτελείται από δύο κύριες εφαρμογές οι οποιες χωριζονται σε 4-5 κλασεις ωστε ο κωδικας να ειναι πιο οργανωμένος και κατανοητός

=== Streaming Server:

O streaming server υλοποιηθηκε ωστε να μπορει να υποστηρίζει πολλους clients ταυτοχρονα και να ειναι multithreaded. Ο server ειναι υπευθυνος για την διαχειριση των βιντεο και την μετατροπη τους σε διαφορετικες αναλυσεις και φορμες μεσω του FFmpeg. Επικοινωνει με τον client μεσω Java Sockets και εχει τις εξης κλασεις: +    

       - *Server.class: Υλοποιεί την κλάση του server, διαχειρίζεται τις συνδέσεις και τις ροές δεδομένων (input/output streams).* +
                Συγκεκριμενα χρησιμοποιεί thread pool για να μπορει να διαχειριζεται πολλαπλους clients ταυτοχρονα. Ο server μπορει να γινει initiate σε οποια πορτα θελουμε με την default να ειναι η 5058. Επειτα απο την δημιουργία του socket γινετε initialize ο VideoManager και επειτα ο Server αναμενει connections απο τους clients. Οταν ενας client συνδεθεί, με την χρηση της συναρτησης handleNewConnection αποδεσμευει σε ενα Thread τον Client με την κλάση ClientHandler. Οταν ο client αποσυνδεθεί, η χρηση ενος anonymous class που υλοποιει το Runnable interface, καλεί την συναρτηση disconnectCallback.run() και ετσι μπορουμε να μειωσουμε τον αριθμο των ενεργων συνδεσεων. 

[source,java]
----
                 clientPool.submit(new ClientHandler(clientSocket, input, output, videoManager, () -> {
                activeConnections.decrementAndGet();
                System.out.println("Client disconnected. Active connections: " + activeConnections.get());
            }));
----             
Τελος η κλάση Server εχει και την συναρτηση shutdownHook που ειναι υπευθυνη για την ομαλη διακοπη του server και την απελευθερωση των πόρων του.
            
       - *ClientHandler.class: Υλοποιεί την κλάση που διαχειρίζεται τις συνδέσεις με τους πελάτες, επεξεργάζεται τις εντολές και στέλνει τα δεδομένα (Streaming).* +
                    Η κλάση αυτη ειναι υπευθυνη για την διαχείριση των clients και την επεξεργασία των εντολών τους. Οταν ο client συνδεθεί, η κλάση ClientHandler αναλαμβάνει να διαχειριστεί την επικοινωνία με τον client. Στην αρχική υλοποίηση, η κλάση ClientHandler εχει την συναρτηση processCommand που ειναι υπευθυνη για την επεξεργασία των εντολών του client απο το Terminal. Οταν ο client στείλει μια εντολή, η κλάση ClientHandler θα την επεξεργαστεί και θα επιστρέψει τα αποτελέσματα στον client. Η κλάση αυτη καλει συναρτησεις της κλασης VideoManager για να παρουσιασει την λιστα με τα διαθεσιμα βιντεο στον client.
                    
       - *VideoManager.class: Υλοποιεί την κλάση που διαχειρίζεται τα βίντεο, τις μετατροπές και τις ροές.*
            Η κλαση αυτη ειναι υπευθυνη για την διαχείριση των βίντεο και την μετατροπή τους σε διαφορετικές αναλύσεις και formats μεσω του FFmpeg (μελλοντικα θα πρεπει να δημιουργει και HLS playlists). +Η κλάση VideoManager επισης βοηθεια με getters ωστε να μπορουμε να εχουμε πληροφορίες για τα βίντεο που εχουμε δημιουργησει. Τα οποια χρησιμοποιουνται απο την κλάση ClientHandler για να παρουσιασουν την λιστα με τα διαθεσιμα βιντεο στον client. Η κλάση VideoManager εχει και συναρτησεις  που ειναι υπευθυνες για την διαχειριση των File Lock και την αποφυγή ταυτόχρονων προσβάσεων στα βίντεο. Αυτη υλοποιηθηκαν ωστε να υπαρχει δυνατοτητα εκτελεσεις πολλαπλων instances του server, οι οποιοι κανουν Load balance μεταξυ τους.
            
            Ετσι οταν ενας server θελει να μετατρεψει ενα βιντεο σε μια συγκεκριμένη αναλυση και φορμα, καλεί την συναρτηση acquireLock και αν το lock εχει αποκτηθεί, τοτε προχωραει στην μετατροπή του βίντεο. Αν το lock δεν εχει αποκτηθεί, τοτε η συναρτηση επιστρέφει false και ο server δεν προχωραει στην μετατροπή του βίντεο. Ετσι αποφεύγουμε ταυτόχρονες προσβάσεις στα βίντεο και διασφαλιζουμε την ακεραιοτητα τους.
       

=== Streaming Client:

        - *Client.class: Υλοποιεί την κλάση του client, διαχειρίζεται τη σύνδεση με τον server και τις ροές δεδομένων (input/output streams) αλλα και το Streaming.*


=== *Παρουσίαση του τελικού υλοποιημένου συστήματος:*
   - *Επικοινωνία Client-Server μέσω Java Sockets, με δυνατότητα εξυπηρέτησης πολλαπλών πελατών ταυτόχρονα (multi-threading).*
   - *Αυτόματη αναγνώριση των αρχείων βίντεο στον κατάλογο και ανάλυση/μετατροπή τους σε διαφορετικές αναλύσεις και μορφές με χρήση FFmpeg (μέσω του Jaffree).*
   - *Καταγραφή σημαντικών γεγονότων και λαθών κατά τη διαδικασία μετατροπής (μέσω καταγραφής στο console, με προτάσεις για μελλοντική ενσωμάτωση Logger).*
   - *Σενάρια εκτέλεσης που περιλαμβάνουν:*
       * *Την εκκίνηση του Server και τη λήψη του αρχικού μηνύματος συστήματος.*
       * *Την επικοινωνία του Client για την αίτηση λίστας βίντεο και την λήψη των σχετικών πληροφοριών.*
       * *Παραδείγματα εκτέλεσης όπου ο χρήστης πληκτρολογεί εντολές LIST, GET κλπ.*

=== *Παρουσίαση των προβλημάτων που αντιμετωπίσατε και πώς αυτά επιλύθηκαν (ή έμειναν ανοικτά):*
   - *Διαχείριση ταυτόχρονων προσβάσεων κατά την εκτέλεση μετατροπών βίντεο: Εφαρμόστηκε σύστημα κλειδώματος αρχείων (File Lock) για αποφυγή διπλών ενεργειών.*
   - *Επικοινωνία Client-Server: Αρχικά προέκυψαν ζητήματα στην σύνδεση και στην ομαλή διαχείριση πολλαπλών συνδέσεων, για τα οποία εφαρμοστεί multi-threading και χρήση shutdown hook για ομαλή διακοπή.*
   - *Ορισμένες λειτουργίες (όπως η δυναμική αλλαγή ποιότητας με βάση το bandwidth και η ενσωμάτωση GUI) παραμένουν σε στάδιο μελλοντικής ανάπτυξης.*

==== *Βελτίωση της λειτουργίας απελευθέρωσης κλειδώματος:*
   - *Πριν την υλοποίηση της βοηθητικής κλάσης (LockWithChannel), παρατηρήθηκε ότι κάποια αρχεία κλειδώματος δεν διαγράφονταν μετά την επιτυχή δημιουργία του βίντεο. Αν προέκυπτε οποιοδήποτε σφάλμα ή αν το αρχείο είχε καταλήξει σε ασυνεπή κατάσταση, παρέμενε στον κατάλογο, εμποδίζοντας νέες μετατροπές.* 
+
[source,java]
----
private static class LockWithChannel {
        final FileLock lock;
        final FileChannel channel;
        final RandomAccessFile raf;

        public LockWithChannel(FileLock lock, FileChannel channel, RandomAccessFile raf) {
            this.lock = lock;
            this.channel = channel;
            this.raf = raf;
        }
    }
----
   - *Με τη δημιουργία της βοηθητικής κλάσης και τον έλεγχο μεταβλητών: Δημιουργήθηκε η κλάση **LockWithChannel** που αποθηκεύει το FileLock, το FileChannel και το RandomAccessFile που προκύπτουν κατά την απόκτηση του κλειδώματος. Όλες οι μεταβλητές ελέγχονται εντός try-catch block, ώστε σε περίπτωση εξαιρέσεων να εξασφαλίζεται ο σωστός τερματισμός (απελευθέρωση πόρων και κλείσιμο Streams).* 
+
[source,java]
----
private void releaseLock(String videoName, String quality, String format) {
        String lockKey = videoName + "-" + quality + "." + format;
        LockWithChannel lockWithChannel = activeLocks.remove(lockKey);
        File videoDir = getVideoDirectory();
        File lockFile = new File(videoDir, lockKey + ".lock");
        
        try {
            if (lockWithChannel != null) {
                // Release lock if valid
                try {
                    if (lockWithChannel.lock != null && lockWithChannel.lock.isValid()) {
                        lockWithChannel.lock.release();
                        System.out.println("Lock released for: " + lockKey);
                    }
                } catch (Exception e) {
                    System.err.println("Error releasing file lock: " + e);
                }
                // Close channel
                try {
                    if (lockWithChannel.channel != null && lockWithChannel.channel.isOpen()) {
                        lockWithChannel.channel.close();
                    }
                } catch (Exception e) {
                    System.err.println("Error closing channel: " + e);
                }
                // Close RandomAccessFile
                try {
                    if (lockWithChannel.raf != null) {
                        lockWithChannel.raf.close();
                    }
                } catch (Exception e) {
                    System.err.println("Error closing random access file: " + e);
                }
            }
            
            // Delete the lock file
            if (lockFile.exists()) {
                if (!lockFile.delete()) {
                    System.err.println("Warning: Failed to delete lock file: " + lockFile.getAbsolutePath());
                    lockFile.deleteOnExit();
                } else {
                    System.out.println("Lock file deleted: " + lockFile.getName());
                }
            }
        } catch (Exception e) {
            System.err.println("Error during lock release for " + lockKey + ": " + e);
            e.printStackTrace();
            if (lockFile.exists()) {
                lockFile.deleteOnExit();
            }
        }
    }

----
   - *Συνοπτικά, ο ενιαίος έλεγχος μέσα σε try-catch διασφαλίζει ότι κάθε στοιχείο της βοηθητικής κλάσης είναι σωστά ελεγχόμενο και απελευθερωμένο, διορθώνοντας τα αρχικά σφάλματα διαχείρισης πόρων.*

== Συνοψίζοντας
* *Το σύστημα υλοποιεί τις βασικές απαιτήσεις του έργου αλλά αφήνει περιθώρια για επεκτάσεις, όπως:*
  * *την υποστήριξη διαφορετικών πρωτοκόλλων μετάδοσης (UDP, TCP, RTP/UDP),*
  * *την υλοποίηση γραφικού περιβάλλοντος, και*
  * *την ενσωμάτωση συστήματος κρυπτογράφησης για ασφαλή επικοινωνία.*

=== Παραδείγματα υλοποίησης:

1. **Παράδειγμα εκκίνησης του Server:**
   _"Server running on port 5058"_
   _Υλοποιείται ως εξής:_
+
[source,java]
----
   System.out.println("Server running on port " + port);
----

2. **Παράδειγμα διαχείρισης πολλαπλών συνδέσεων:**
   _Χρήση του AtomicInteger:_
+
[source,java]
----
 private static void handleNewConnection(Socket clientSocket) {
        try {
            System.out.println("New client connected: " + clientSocket);
            activeConnections.incrementAndGet();
            
            // Create streams
            DataInputStream input = new DataInputStream(clientSocket.getInputStream());
            DataOutputStream output = new DataOutputStream(clientSocket.getOutputStream());
            
            // Submit to thread pool the last argument is unnamed class dissconnectCallabck that impliments 
            //Runnable so when the client disconnects the disconnectCallback.run() is called and the 
            //below code is executed line 65-66
            clientPool.submit(new ClientHandler(clientSocket, input, output, videoManager, () -> {
                activeConnections.decrementAndGet();
                System.out.println("Client disconnected. Active connections: " + activeConnections.get());
            }));
            
        } catch (IOException e) {
            System.err.println("Error handling connection: " + e.getMessage());
            activeConnections.decrementAndGet();
        }
    }

----

3. **Παράδειγμα χρήσης του File Lock στην μετατροπή βίντεο:**
+
[source,java]
----
   if (!acquireLock(videoName, targetQuality, targetFormat)) {
       System.out.println("Conversion already in progress by another instance: " + videoName + "-" + targetQuality + "." + targetFormat);
       return;
   }
----

4. **Παράδειγμα επεξεργασίας εντολών από τον Client:**
+
[source,java]
----
   if (command.startsWith("LIST")) {
       return videoManager.getVideoList();
   } else if (command.startsWith("GET ")) {
       String videoName = command.substring(4);
       return videoManager.getVideoInfo(videoName);
   }
----
